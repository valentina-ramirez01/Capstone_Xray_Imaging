# ==============================
# File: tools.py
# ==============================
from typing import Tuple
import cv2
import numpy as np


def apply_contrast_brightness(img: np.ndarray, alpha: float = 1.0, beta: float = 0.0) -> np.ndarray:
    """
    Adjust contrast and brightness using:
      output = alpha * img + beta
    Typical ranges: alpha (0.1..5.0), beta (-100..+100).
    """
    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)


def apply_zoom(img: np.ndarray, zoom: float = 1.0) -> np.ndarray:
    """Center zoom. For zoom>=1.0: crop the center and resize back to original size."""
    if zoom <= 1.0:
        return img
    h, w = img.shape[:2]
    nh, nw = int(h / zoom), int(w / zoom)
    y1 = max((h - nh) // 2, 0)
    x1 = max((w - nw) // 2, 0)
    crop = img[y1:y1 + nh, x1:x1 + nw]
    return cv2.resize(crop, (w, h), interpolation=cv2.INTER_LINEAR)


def fit_in_window(img: np.ndarray, max_w: int = 1280, max_h: int = 720) -> np.ndarray:
    """Shrink to fit inside a window without upscaling."""
    h, w = img.shape[:2]
    scale = min(max_w / w, max_h / h, 1.0)
    if scale < 1.0:
        img = cv2.resize(img, (int(w * scale), int(h * scale)), interpolation=cv2.INTER_AREA)
    return img


# ==============================
# File: gallery.py
# ==============================
import os
import glob
from typing import List, Optional
import cv2
import numpy as np

from tools import apply_contrast_brightness, apply_zoom, fit_in_window


class Gallery:
    """
    Stateful image gallery with callable controls + robust key handling + trackbars.

    Keys:
      ←/→ or A/D : prev/next
      Z/X        : zoom ±10%    (zoom 1.0 .. 4.0)
      [ / ]      : contrast ±0.1 (alpha 0.1 .. 5.0)
      ; / '      : brightness ±5 (beta -100 .. 100)
      R          : reset (zoom=1, alpha=1, beta=0)
      E          : export processed copy to captures/edited_XXXX.png
      H or ?     : print help
      K          : print last key code (diagnostics)
      Q or ESC   : quit

    Also exposes callable methods: set/adjust_zoom, set/adjust_contrast, set/adjust_brightness, reset_view.

    Trackbars (top of window) mirror the same controls; you can use them if keys aren't recognized.
    """

    def __init__(self, image_paths: List[str], window_name: str = "Gallery"):
        self.files = image_paths
        self.win = window_name
        self.idx = 0

        # Editable viewer state
        self.alpha: float = 1.0   # contrast
        self.beta: float = 0.0    # brightness
        self.zoom: float = 1.0    # zoom factor

        self._last_processed: Optional[np.ndarray] = None

    # ----- public callable methods -----
    def set_contrast(self, alpha: float) -> None:
        self.alpha = float(np.clip(alpha, 0.1, 5.0))

    def adjust_contrast(self, d_alpha: float) -> None:
        self.set_contrast(self.alpha + d_alpha)

    def set_brightness(self, beta: float) -> None:
        self.beta = float(np.clip(beta, -100.0, 100.0))

    def adjust_brightness(self, d_beta: float) -> None:
        self.set_brightness(self.beta + d_beta)

    def set_zoom(self, z: float) -> None:
        self.zoom = float(np.clip(z, 1.0, 4.0))

    def adjust_zoom(self, step: float) -> None:
        # step is fractional: +0.10 => +10%
        self.set_zoom(self.zoom * (1.0 + step))

    def reset_view(self) -> None:
        self.alpha, self.beta, self.zoom = 1.0, 0.0, 1.0

    # ----- internal helpers -----
    def _load(self, i: int) -> Optional[np.ndarray]:
        path = self.files[i]
        img = cv2.imread(path, cv2.IMREAD_COLOR)
        return img

    def _render_current(self) -> np.ndarray:
        path = self.files[self.idx]
        img = self._load(self.idx)
        if img is None:
            canvas = np.zeros((240, 960, 3), dtype=np.uint8)
            cv2.putText(canvas, f"Couldn't read: {os.path.basename(path)}", (20, 140),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2, cv2.LINE_AA)
            self._last_processed = canvas
            return canvas

        # Apply operations: zoom -> contrast/brightness
        proc = apply_zoom(img, self.zoom)
        proc = apply_contrast_brightness(proc, self.alpha, self.beta)

        # Compose a display frame and draw HUD
        disp = fit_in_window(proc, 1280, 720)
        hud = (
            f"{self.idx+1}/{len(self.files)}  {os.path.basename(path)}  |  "
            f"zoom {self.zoom:.2f}x  alpha {self.alpha:.2f}  beta {self.beta:.0f}"
        )
        cv2.putText(disp, hud, (12, 26), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 3, cv2.LINE_AA)
        cv2.putText(disp, hud, (12, 26), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 1, cv2.LINE_AA)

        self._last_processed = proc
        return disp

    def _export_current(self, out_dir: str = "captures") -> Optional[str]:
        if self._last_processed is None:
            return None
        os.makedirs(out_dir, exist_ok=True)
        n = len(glob.glob(os.path.join(out_dir, "edited_*.png")))
        out_path = os.path.join(out_dir, f"edited_{n:04d}.png")
        return out_path if cv2.imwrite(out_path, self._last_processed) else None

    def _help(self):
        print("
Gallery controls:
  ←/→ or A/D : prev/next
  Z/X        : zoom ±10%
  [ / ]      : contrast ±0.1
  ; / '      : brightness ±5
  R          : reset
  E          : export edited copy
  H or ?     : help
  K          : print last key code (debug)
  Q or ESC   : quit
")

    # ----- event loop -----
    def run(self, start_at: Optional[str] = None) -> None:
        if not self.files:
            print("No images to show.")
            return
        if start_at and start_at in self.files:
            self.idx = self.files.index(start_at)

        cv2.namedWindow(self.win, cv2.WINDOW_AUTOSIZE)

        # Trackbars as reliable fallback controls
        def _on_zoom(v):
            # v in [100..400] -> 1.0..4.0
            self.set_zoom(max(1.0, v / 100.0))
        def _on_alpha(v):
            # v in [10..500] -> 0.1..5.0
            self.set_contrast(max(10, v) / 100.0)
        def _on_beta(v):
            # v in [0..200] -> -100..100
            self.set_brightness(v - 100)

        cv2.createTrackbar("Zoom x100", self.win, int(self.zoom * 100), 400, _on_zoom)
        cv2.createTrackbar("Alpha x100", self.win, int(self.alpha * 100), 500, _on_alpha)
        cv2.createTrackbar("Beta +100", self.win, int(self.beta + 100), 200, _on_beta)

        last_key = None
        self._help()

        while True:
            cv2.imshow(self.win, self._render_current())
            try:
                k = cv2.waitKeyEx(0) & 0xFFFFFFFF
            except Exception:
                k = cv2.waitKey(0) & 0xFF
            last_key = k

            # Quit
            if k in (27, ord('q'), ord('Q')):
                cv2.destroyWindow(self.win)
                break

            # Prev / Next (support common codes across OSes) + A/D fallback
            elif k in (81, 2424832, ord('a'), ord('A')):   # left arrow or A
                self.idx = (self.idx - 1) % len(self.files)
            elif k in (83, 2555904, ord('d'), ord('D')):   # right arrow or D
                self.idx = (self.idx + 1) % len(self.files)

            # Zoom
            elif k in (ord('z'), ord('Z')):
                self.adjust_zoom(+0.10)
                cv2.setTrackbarPos("Zoom x100", self.win, int(self.zoom * 100))
            elif k in (ord('x'), ord('X')):
                self.adjust_zoom(-0.10)
                cv2.setTrackbarPos("Zoom x100", self.win, int(self.zoom * 100))

            # Contrast
            elif k == ord(']'):
                self.adjust_contrast(+0.10)
                cv2.setTrackbarPos("Alpha x100", self.win, int(self.alpha * 100))
            elif k == ord('['):
                self.adjust_contrast(-0.10)
                cv2.setTrackbarPos("Alpha x100", self.win, int(self.alpha * 100))

            # Brightness
            elif k in (ord("'"),):
                self.adjust_brightness(+5.0)
                cv2.setTrackbarPos("Beta +100", self.win, int(self.beta + 100))
            elif k == ord(';'):
                self.adjust_brightness(-5.0)
                cv2.setTrackbarPos("Beta +100", self.win, int(self.beta + 100))

            # Reset
            elif k in (ord('r'), ord('R')):
                self.reset_view()
                cv2.setTrackbarPos("Zoom x100", self.win, int(self.zoom * 100))
                cv2.setTrackbarPos("Alpha x100", self.win, int(self.alpha * 100))
                cv2.setTrackbarPos("Beta +100", self.win, int(self.beta + 100))

            # Export
            elif k in (ord('e'), ord('E')):
                out = self._export_current("captures")
                print(f"Exported: {out}" if out else "Export failed.")

            # Diagnostics
            elif k in (ord('h'), ord('H'), ord('?')):
                self._help()
            elif k in (ord('k'), ord('K')):
                print(f"Last key code: {last_key}")

# ==============================
# File: io_utils.py
# ==============================
import os
import glob
from typing import Tuple
import cv2
import numpy as np


def capture_and_save_frame(frame_bgr: np.ndarray, save_dir: str = "captures") -> Tuple[str, np.ndarray]:
    """Save a BGR frame to disk as PNG. Returns (path, copy_of_frame)."""
    os.makedirs(save_dir, exist_ok=True)
    count = len(glob.glob(os.path.join(save_dir, "capture_*.png")))
    path = os.path.join(save_dir, f"capture_{count:04d}.png")
    ok = cv2.imwrite(path, frame_bgr)
    if not ok:
        raise RuntimeError("Failed to save image")
    return path, frame_bgr.copy()


# ==============================
# File: camera.py
# ==============================
import os
import glob
from typing import Callable, Optional
import numpy as np
import cv2

from gallery import Gallery
from io_utils import capture_and_save_frame


def _gather_all_images(save_dir: str) -> list[str]:
    patterns = ("*.png", "*.jpg", "*.jpeg", "*.bmp", "*.tif", "*.tiff")
    files: list[str] = []
    for p in patterns:
        files.extend(glob.glob(os.path.join(save_dir, p)))
    files.sort()
    return files


def start_camera(
    cam_index: int = 1,
    window_name: str = "Webcam Feed",
    on_capture: Optional[Callable[[str, np.ndarray], None]] = None,
    save_dir: str = "captures",
) -> None:
    """
    Live preview + capture + open gallery.
    Keys (in live view):
      's' : save current frame to disk
      'g' : open gallery with current session's images
      'G' : open gallery with ALL images in save_dir (any common image ext)
      'q' : quit
    """
    cap = cv2.VideoCapture(cam_index)
    if not cap.isOpened():
        print(f"Could not open camera at index {cam_index}")
        return

    os.makedirs(save_dir, exist_ok=True)
    session_paths: list[str] = []
    last_path: Optional[str] = None

    print("Camera running. Keys: 's' save, 'g' session gallery, 'G' all, 'q' quit.")
    while True:
        ret, frame = cap.read()
        if not ret:
            print("Failed to grab frame")
            break

        cv2.imshow(window_name, frame)
        key = cv2.waitKey(1) & 0xFF

        if key == ord('s'):
            try:
                path, frame_np = capture_and_save_frame(frame, save_dir=save_dir)
                session_paths.append(path)
                last_path = path
                print(f"Saved: {path}")
                if on_capture is not None:
                    on_capture(path, frame_np)
            except Exception as e:
                print(f"Capture error: {e}")

        elif key == ord('g'):
            if not session_paths:
                print("No session images yet. Press 's' to capture.")
            else:
                gal = Gallery(session_paths, window_name="Gallery (session)")
                gal.run(start_at=last_path)
                cv2.imshow(window_name, frame)  # restore live window

        elif key == ord('G'):
            all_paths = _gather_all_images(save_dir)
            if not all_paths:
                print(f"No images found in '{save_dir}'.")
            else:
                gal = Gallery(all_paths, window_name="Gallery (all)")
                gal.run(start_at=last_path)
                cv2.imshow(window_name, frame)

        elif key == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()


# ==============================
# File: processing.py
# (Optional) Processing pipelines that use tools.py; separate from UI/IO.
# ==============================
from typing import Dict, Any
import numpy as np
from tools import apply_contrast_brightness, apply_zoom


def apply_pipeline(img_bgr: np.ndarray, cfg: Dict[str, Any]) -> np.ndarray:
    """
    Example pipeline applying zoom and contrast/brightness based on a config dict.
    cfg keys (all optional):
      - zoom: float >= 1.0
      - alpha: contrast multiplier
      - beta: brightness offset
    """
    z = float(cfg.get("zoom", 1.0))
    a = float(cfg.get("alpha", 1.0))
    b = float(cfg.get("beta", 0.0))

    out = apply_zoom(img_bgr, z)
    out = apply_contrast_brightness(out, a, b)
    return out


# ==============================
# File: main.py
# ==============================
import numpy as np
from camera import start_camera


def handle_capture(filepath: str, frame: np.ndarray) -> None:
    print(f"Captured to {filepath} | frame shape: {frame.shape}")


def main():
    # Use cam_index=1 to prefer external USB camera (adjust as needed).
    start_camera(cam_index=1, on_capture=handle_capture, save_dir="captures")


if __name__ == "__main__":
    main()
